diff --git a/cgi_fcgi/slog_flogin.cpp b/cgi_fcgi/slog_flogin.cpp
index d9b0b65..f085f36 100644
--- a/cgi_fcgi/slog_flogin.cpp
+++ b/cgi_fcgi/slog_flogin.cpp
@@ -51,6 +51,8 @@
 #include <cgi_head.h>
 #include <cgi_comm.h>
 
+#define MAX_LOG_HISTORY_PER_USER 12
+
 // table flogin_type status 状态码
 #define STATUS_USE 0
 #define STATUS_DELETE 1
@@ -174,6 +176,8 @@ static int SetFreeAccountInfo(CGI *cgi, HDF *hdf)
 					iCommCount++;
 				else
 					iManagerCount++;
+				DEBUG_LOG("set free user info - name:%s, type:%d, last actime:%u",
+					it->second.szUserName, it->second.iLoginType, it->first);
 			}
 		}
 	}
@@ -309,6 +313,49 @@ static int GetBindxrkmonitorUid()
 	return iBindXrkmonitorUid;
 }
 
+static void AddLoginHistory(FloginInfo *psess)
+{
+	IM_SQL_PARA* ppara = NULL;
+	InitParameter(&ppara);
+	AddParameter(&ppara, "user_id", psess->iUserId, "DB_CAL");
+	AddParameter(&ppara, "login_time", stConfig.dwCurTime, "DB_CAL");
+	AddParameter(&ppara, "valid_time", stConfig.dwCurTime+psess->iLoginExpireTime, "DB_CAL");
+	AddParameter(&ppara, "login_remote_address", stConfig.remote, NULL);
+	AddParameter(&ppara, "receive_server", g_szLocalServerIp, NULL);
+	const char *ptmp = hdf_get_value(stConfig.cgi->hdf, "HTTP.Referer", NULL);
+	if(ptmp != NULL)
+		AddParameter(&ppara, "referer", ptmp, NULL);
+	ptmp = hdf_get_value(stConfig.cgi->hdf, "HTTP.UserAgent", NULL);
+	if(ptmp != NULL)
+		AddParameter(&ppara, "user_agent", ptmp, NULL);
+
+	std::string strSql;
+	strSql = "insert into flogin_history";
+	JoinParameter_Insert(&strSql, stConfig.qu->GetMysql(), ppara);
+	ReleaseParameter(&ppara);
+	stConfig.qu->execute(strSql);
+	DEBUG_LOG("add login history, sql:%s", strSql.c_str());
+
+	// 只保留 MAX_LOG_HISTORY_PER_USER 条记录
+	char sSql[256] = {0};
+	snprintf(sSql, sizeof(sSql), "select id from flogin_history where user_id=%d order by id asc", psess->iUserId);
+	stConfig.qu->get_result(sSql);
+	int iCount = stConfig.qu->num_rows();
+	if(iCount > MAX_LOG_HISTORY_PER_USER) 
+	{
+		DEBUG_LOG("login history records:%d over limit:%d, try delete", iCount, MAX_LOG_HISTORY_PER_USER);
+		Query qutmp(*stConfig.db);
+		while(iCount > MAX_LOG_HISTORY_PER_USER && stConfig.qu->fetch_row())
+		{
+			snprintf(sSql, sizeof(sSql), "delete from flogin_history where id=%d", stConfig.qu->getval("id"));
+			qutmp.execute(sSql);
+			iCount--;
+		}
+	}
+	stConfig.qu->free_result();
+}
+
+
 static int CheckLogin(HDF *hdf)
 {
 	const char *puser = hdf_get_value(hdf, "Query.username", NULL);
@@ -388,6 +435,7 @@ static int CheckLogin(HDF *hdf)
 			stConfig.qu->free_result();
 			stConfig.qu->execute(sBuf);
 			KickOldLoginInfo(psess, iFreeIndex);
+			AddLoginHistory(psess);
 			return CHECK_RESULT_SUCCESS;
 		}
 		REQERR_LOG("check user login failed, sql:%s, dbpass:%s, ppass:%s, user name:%s login type:%d",
